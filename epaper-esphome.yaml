esphome:
  name: wave001
  friendly_name: Wave 001
  
  # Configurazione del comportamento all'avvio del dispositivo
  on_boot:
    priority: 200.0
    then:
      # Attesa che il modulo NTP abbia una data valida
      - wait_until:
          condition:
            lambda: 'return id(ntp).now().is_valid();'
          timeout: 5s
      # Incremento del contatore di risvegli
      - lambda: 'id(contatore_risvegli) += 1;'
      # Attesa per stabilitÃ  dei componenti e aggiornamento ADC
      - delay: 700ms
      - component.update: idADC
      - delay: 600ms
      # Verifica la validitÃ  del sensore durata pagina1
      - wait_until:
          condition:
            lambda: 'return !isnan(id(durata_pagina1_ha).state);'
          timeout: 5s
      - lambda: |-
          // Se durata_pagina1_ha ha un valore valido, usa quello
          if (id(durata_pagina1_ha).state > 0) {
            id(pagina1_durata) = int(id(durata_pagina1_ha).state);  // Imposta la durata da HA se valida
          } else {
            id(pagina1_durata) = 30;  // Fallback se non disponibile
          }
      # Verifica la validitÃ  del sensore durata sleep diurno
      - wait_until:
          condition:
            lambda: 'return !isnan(id(durata_sleep_diurno_ha).state);'
          timeout: 5s
      - lambda: |-
          if (id(durata_sleep_diurno_ha).state > 0) {
            id(intervallo_sleep) = int(id(durata_sleep_diurno_ha).state);
          } else {
            id(intervallo_sleep) = 20;
          }
      # Verifica la validitÃ  degli orari di partenza e fine deep sleep notturno
      - lambda: |-
          if (!isnan(id(sleep_notte_inizio_hour).state) && !isnan(id(sleep_notte_inizio_minute).state)) {
            id(sleep_notte_inizio_minuti) = int(id(sleep_notte_inizio_hour).state) * 60 + int(id(sleep_notte_inizio_minute).state);
          }
          if (!isnan(id(sleep_notte_fine_hour).state) && !isnan(id(sleep_notte_fine_minute).state)) {
            id(sleep_notte_fine_minuti) = int(id(sleep_notte_fine_hour).state) * 60 + int(id(sleep_notte_fine_minute).state);
          }

      # Pulizia completa al mattino o ogni risveglio
      - if:
          condition:
            lambda: |-
              auto now = id(ntp).now();
              bool mattino = id(primo_risveglio_mattino) && (now.hour >= 7 && now.hour < 9);
              bool ogni_1_risveglio = id(contatore_risvegli) >= 1;
              return mattino || ogni_1_risveglio;
          then:
          # Resetta flag e contatori
          - lambda: |-
              id(contatore_risvegli) = 0;
              id(primo_risveglio_mattino) = false;

      # Attesa che i dati siano aggiornati
      - wait_until:
          condition:
            lambda: 'return id(dati_aggiornati) == true;'
      # Forza aggiornamento RSSI Wi-Fi
      - component.update: segnale_wifi
      - delay: 300ms            
      # Aggiorna il display e marca i dati iniziali come ricevuti      
      - component.update: eink_display      
      - lambda: 'id(dati_iniziali_ricevuti) = true;'
      # Controlla se Ã¨ il momento di dormire o di avviare il ciclo pagina
      - script.execute: check_sleep_time
      - if:
          condition:
            lambda: 'return id(vai_a_dormire);'
          then:
            - logger.log: "ðŸŒ™ Ãˆ ora di dormire â†’ Schermata nera e deep sleep"
            - display.page.show: pagina2
            - component.update: eink_display
            - delay: 700ms
            - deep_sleep.enter: controllo_deep_sleep
          else:
            - script.execute: page_cycle

# Configurazione hardware ESP32
esp32:
  board: esp32dev
  framework:
    type: arduino

# Log di diagnostica
logger:

# Configurazione API per Home Assistant
api:
  encryption:
    key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# Configurazione OTA per aggiornamenti firmware
ota:
  - platform: esphome
    password: !secret otaxxxxxxx

# Configurazione Wi-Fi
wifi:
  ssid: !secret wifixxxxxxxxx
  password: !secret wifixxxxxxxx
  manual_ip:
    static_ip: xxx.xxx.xxx.xxx
    gateway: xxx.xxx.xxx.xxx
    subnet: xxx.xxx.xxx.xxx
  fast_connect: true

  # Access Point di fallback
  ap:
    ssid: "Wave001 Hotspot"
    password: !secret apxxxxxxxx

  # ModalitÃ  di risparmio energetico
  power_save_mode: light  

# Portale Captive (per connessione diretta)
captive_portal:

# Variabili globali per la gestione dello stato
globals:
  # Stato dei dati aggiornati
  - id: dati_aggiornati
    type: bool
    restore_value: no
    initial_value: 'false'
  # Stato dei dati iniziali ricevuti
  - id: dati_iniziali_ricevuti
    type: bool
    restore_value: no
    initial_value: 'false'
  # Flag per deep sleep  
  - id: vai_a_dormire
    type: bool
    restore_value: no
    initial_value: 'false'
  # Selettore per il cambio pagina   
  - id: selettore_pagina
    type: int
    restore_value: no
    initial_value: '1'
  # Flag per il primo risveglio al mattino        
  - id: primo_risveglio_mattino
    type: bool
    restore_value: no
    initial_value: 'true'
  # Backup durata visualizzazione delle pagine    
  - id: pagina1_durata
    type: int
    restore_value: no
    initial_value: '30'
  # Backup durata deep sleep  
  - id: intervallo_sleep
    type: int
    restore_value: no
    initial_value: '20'
  # Backup inizio deep sleep notte
  - id: sleep_notte_inizio_minuti
    type: int
    restore_value: no
    initial_value: '1350'  # fallback: 22:30
  # Fine Deep Sleep Notte  
  - id: sleep_notte_fine_minuti
    type: int
    restore_value: no
    initial_value: '510'   # fallback: 08:30      
  # Contatore risvegli per pulizie
  - id: contatore_risvegli
    type: int
    restore_value: yes
    initial_value: '0'

# Pulsanti per spegnere o riavviare
button:
  - platform: shutdown
    name: "Spegni"
  - platform: restart
    name: "Riavvia"

# Script personalizzati
script:
  # Controllo per il deep sleep notturno
  - id: check_sleep_time
    then:
      - lambda: |-
          auto now = id(ntp).now();
          if (!now.is_valid()) {
            id(vai_a_dormire) = false;
            return;
          }
          int total_minutes = now.hour * 60 + now.minute;
          int start = id(sleep_notte_inizio_minuti);  // da globals
          int end   = id(sleep_notte_fine_minuti);    // da globals

          bool in_night;
          if (start < end) {
            // es. 22:00â€“07:00 non succede: start(1320) > end(420), gestito sotto
            in_night = (total_minutes >= start && total_minutes < end);
          } else {
            // periodo che passa da un giorno al successivo (es. 22:00â€“07:00)
            in_night = (total_minutes >= start || total_minutes < end);
          }

          if (in_night) {
            int delta = end - total_minutes;
            if (delta <= 0) delta += 24 * 60;           // wrap-around
            int seconds_to_wakeup = delta * 60 - now.second;
            ESP_LOGI("sleep", "ðŸŒ™ Deep sleep notturno fino a %02d:%02d (in %d sec)", 
                     end/60, end%60, seconds_to_wakeup);
            id(controllo_deep_sleep).set_sleep_duration(seconds_to_wakeup * 1000);
            id(vai_a_dormire) = true;
          } else {
            id(vai_a_dormire) = false;
          }
  # Gestione del ciclo pagina e deep sleep diurno
  - id: page_cycle
    mode: restart
    then:
      # Mostra la prima pagina e aggiorna il display
      - display.page.show: pagina1
      - component.update: eink_display
      - delay: !lambda 'return id(pagina1_durata) * 1000;'

      # Calcola il tempo per il prossimo slot (00, 20, 40 minuti)
      - lambda: |-
          auto now = id(ntp).now();
          if (now.is_valid()) {
            int slot_interval = id(intervallo_sleep);  // Intervallo in minuti
            int current_minutes = now.minute;
            int current_seconds = now.second;
            int minutes_since_midnight = now.hour * 60 + now.minute;

            int remainder = minutes_since_midnight % slot_interval;
            int minutes_to_next_slot = slot_interval - remainder;
            if (minutes_to_next_slot == 0) minutes_to_next_slot = slot_interval;

            int seconds_to_sleep = minutes_to_next_slot * 60 - current_seconds;
            if (seconds_to_sleep <= 0) seconds_to_sleep = 60; // fallback minimo

            ESP_LOGI("sleep", "â±ï¸ Prossimo slot tra %d secondi (ogni %d min)", seconds_to_sleep, slot_interval);
            id(controllo_deep_sleep).set_sleep_duration(seconds_to_sleep * 1000);
          }

      # Entra in deep sleep
      - deep_sleep.enter: controllo_deep_sleep

# Configurazione oraria
time:
  - platform: sntp
    id: ntp
    timezone: Europe/Rome
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org

  - platform: homeassistant
    id: homeassistant_time

# Configurazione deep sleep
deep_sleep:
  id: controllo_deep_sleep
  sleep_duration: 17min


sensor:
  # Durata Pagina1
  - platform: homeassistant
    id: durata_pagina1_ha
    entity_id: input_number.durata_pagina1
    internal: true

  # Durata Deep Sleep
  - platform: homeassistant
    id: durata_sleep_diurno_ha
    entity_id: input_number.durata_sleep_diurno
    internal: true  

  # Ora e minuti di inizio sleep notturno
  - platform: homeassistant
    id: sleep_notte_inizio_hour
    entity_id: input_datetime.inizio_sleep_notturno
    attribute: hour
    internal: true

  - platform: homeassistant
    id: sleep_notte_inizio_minute
    entity_id: input_datetime.inizio_sleep_notturno
    attribute: minute
    internal: true

  # Ora e minuti di fine sleep notturno
  - platform: homeassistant
    id: sleep_notte_fine_hour
    entity_id: input_datetime.fine_sleep_notturno
    attribute: hour
    internal: true

  - platform: homeassistant
    id: sleep_notte_fine_minute
    entity_id: input_datetime.fine_sleep_notturno
    attribute: minute
    internal: true

  # Sensore ADC
  - platform: adc
    name: ADC
    icon: mdi:flash
    id: idADC
    pin: GPIO32
    attenuation: 12db
    update_interval: 30s
    accuracy_decimals: 3
    internal: true
    filters:
    - sliding_window_moving_average:
        window_size: 10
        send_every: 2

  # Calcolo della tensione reale della batteria
  - platform: copy
    name: Batteria Voltaggio
    icon: mdi:flash
    id: Batteria_Voltaggio
    source_id: idADC
    accuracy_decimals: 2
    filters:
      - multiply: 2  

  # Percentuale della batteria (per 18650 3.7V)
  - platform: copy
    name: Batteria Livello
    icon: mdi:battery
    id: Batteria_Livello
    source_id: Batteria_Voltaggio 
    device_class: battery
    unit_of_measurement: '%'
    accuracy_decimals: 0
    filters:
    - calibrate_linear:
        - 3.30 -> 0     
        - 3.50 -> 10
        - 3.60 -> 30
        - 3.70 -> 50
        - 3.80 -> 70
        - 3.90 -> 85
        - 4.00 -> 93
        - 4.10 -> 97
        - 4.20 -> 100
    - lambda: |-
        if (x > 100.0) return 100.0;
        if (x < 0.0) return 0.0;
        return x;

  # Segnale WiFi
  - platform: wifi_signal
    name: "WiFi Signal"
    id: segnale_wifi
    update_interval: 60s

  # Numero di giorni visualizzati in previsioni 
  - platform: homeassistant
    id: giorni_previsioni_ha
    entity_id: input_number.giorni_previsioni
    internal: true

  # Numero di ore visualizzate in previsioni 
  - platform: homeassistant
    id: ore_previsioni_ha
    entity_id: input_number.ore_previsioni
    internal: true

  # Crea un sensore per la gestione dell'ultimo aggiornamento.
  - platform: template
    name: Display Ultimo Aggiornamento
    device_class: timestamp
    entity_category: "diagnostic"
    id: ultimo_aggiornamento_display

  # Sensori Meteo
  - platform: homeassistant
    id: meteo_temperatura_ora  
    entity_id: sensor.epaperdisplay_data 
    attribute: meteo_temperatura_ora       
    internal: true
    on_value:
      then:
        - lambda: 'id(dati_aggiornati) = true;' 

  - platform: homeassistant
    id: meteo_umidita_ora
    entity_id: sensor.epaperdisplay_data    
    attribute: meteo_umidita_ora
    unit_of_measurement: "%"
    internal: true

  - platform: homeassistant
    id: meteo_pressione_ora
    entity_id: sensor.epaperdisplay_data    
    attribute: meteo_pressione_ora
    internal: true

  - platform: homeassistant
    id: meteo_precipitazione_ora
    entity_id: sensor.epaperdisplay_data    
    attribute: precipitazione
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_1d    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_1d    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_2d    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_2d    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_3d    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_3d    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_4d    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_4d    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_1o    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_1o    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_2o    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_2o    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_3o    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_3o    
    internal: true

  - platform: homeassistant    
    id: meteo_temperatura_4o    
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_temperatura_4o    
    internal: true

text_sensor:

  # sun/moon
  - platform: homeassistant
    entity_id: sun.sun
    id: sun
    internal: true

  # Selettore Previsione Giornaliero/Orario
  - platform: homeassistant
    id: tipo_previsioni_ha
    entity_id: input_select.tipo_previsioni
    internal: true

  # Selettore Data Numerica/Alfanumerica
  - platform: homeassistant
    id: scelta_data
    entity_id: input_select.scelta_data
    internal: true

  # Sensori Meteo
  - platform: homeassistant
    id: meteo_condizione_ora
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_ora
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_1d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_1d
    internal: true

  - platform: homeassistant    
    id: meteo_giorno_1d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_giorno_1d
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_2d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_2d
    internal: true

  - platform: homeassistant    
    id: meteo_giorno_2d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_giorno_2d
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_3d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_3d
    internal: true

  - platform: homeassistant    
    id: meteo_giorno_3d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_giorno_3d
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_4d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_4d
    internal: true

  - platform: homeassistant    
    id: meteo_giorno_4d
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_giorno_4d
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_1o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_1o
    internal: true

  - platform: homeassistant    
    id: meteo_orario_1o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_orario_1o
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_2o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_2o
    internal: true

  - platform: homeassistant    
    id: meteo_orario_2o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_orario_2o
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_3o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_3o
    internal: true

  - platform: homeassistant    
    id: meteo_orario_3o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_orario_3o
    internal: true

  - platform: homeassistant    
    id: meteo_condizione_4o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_condizione_1d
    internal: true

  - platform: homeassistant    
    id: meteo_orario_4o
    entity_id: sensor.epaperdisplay_data
    attribute: meteo_orario_4o
    internal: true

  # Sensori Eventi Calendario
  - platform: homeassistant
    id: eventi_lunedi
    entity_id: input_text.lunedi_eventi  

  - platform: homeassistant
    id: eventi_martedi
    entity_id: input_text.martedi_eventi 

  - platform: homeassistant
    id: eventi_mercoledi
    entity_id: input_text.mercoledi_eventi 

  - platform: homeassistant
    id: eventi_giovedi
    entity_id: input_text.giovedi_eventi 

  - platform: homeassistant
    id: eventi_venerdi
    entity_id: input_text.venerdi_eventi 

  - platform: homeassistant
    id: eventi_sabato
    entity_id: input_text.sabato_eventi 

  - platform: homeassistant
    id: eventi_domenica
    entity_id: input_text.domenica_eventi 

font:
# Per la Data Numerica e per il Giorno alfanumerico
  - file: "fonts/Din-Condensed-Bold.ttf"
    id: xtra_large_font
    size: 112
    glyphs:
      [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', '/']

# Intestazioni Sezioni
  - file: "fonts/GoogleSans-Bold.ttf"
    id: medium_fontb
    size: 36
    glyphs: &font-glyphs
      ['&', '@', '!', ',', '.', '"', '%', '(', ')', '+', '-', '_', ':', 'Â°', '0',
       '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
       'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
       'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', 'a', 'b', 'c', 'd', 'e', 'f',
       'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
       'u', 'v', 'w', 'x', 'y', 'z', '/', 'Ã¬', 'ÃŒ', 'â€¢']

# Temperatura Esterna, Giorno della Settimana e Mese alfanumerico
  - file: "fonts/Din-Condensed-Bold.ttf"
    id: xtra_large_fontm
    size: 90 
    glyphs: *font-glyphs

# Solo per data alfanumerica
  - file: "fonts/Din-Condensed-Bold.ttf"
    id: xtra_large_fontm2
    size: 54
    glyphs: *font-glyphs

# Non Usato
  - file: "fonts/GoogleSans-Medium.ttf"
    id: medium_fontm
    size: 40
    glyphs: *font-glyphs

  - file: "fonts/GoogleSans-Medium.ttf"
    id: small_font
    size: 26
    glyphs: *font-glyphs


  - file: "fonts/GoogleSans-Medium.ttf"
    id: xtra_small_font
    size: 18
    glyphs: *font-glyphs


    # https://pictogrammers.github.io/@mdi/font/5.3.45/
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: font_icons_small
    size: 26
    glyphs:
      - "\U000F12A6" # battery-charging-high
      - "\U000F0E17" # calendar-month
      - "\U000F007A"  # mdi-battery-10               â€”
      - "\U000F007B"  # mdi-battery-20               
      - "\U000F007C"  # mdi-battery-30           
      - "\U000F007D"  # mdi-battery-40           
      - "\U000F007E"  # mdi-battery-50          
      - "\U000F007F"  # mdi-battery-60          
      - "\U000F0080"  # mdi-battery-70               
      - "\U000F0081"  # mdi-battery-80               
      - "\U000F0082"  # mdi-battery-90  
      - "\U000F0079"  # mdi-battery-100           
      - "\U000F0169"  # mdi-battery-outline 
      - "\U000F092F"  # mdi-wifi-off
      - "\U000F091F"  # mdi-wifi-strength-1
      - "\U000F0922"  # mdi-wifi-strength-2
      - "\U000F0925"  # mdi-wifi-strength-3
      - "\U000F0928"  # mdi-wifi-strength-4
      - "\U000F05AA"  # mdi-wifi-strength-outline                


  - file: "fonts/materialdesignicons-webfont.ttf"
    id: font_icons_medium
    size: 32
    glyphs:
      - "\U000F10C2" # Temperature High
      - "\U000F10C3" # Temperature Low
      - "\U000F1A71" # mdi-snowflake-thermometer
      - "\U000F050F" # mdi-thermometer
      - "\U000F029A" # mdi-gauge
      - "\U000F058E" # mdi-water-percent
      - "\U000F07E4" # mdi-molecule-co2
      - "\U000F059D" # mdi-weather-windy
      - "\U000F04E0" # mdi-sunglasses      
      - "\U000F0E17" # mdi-calendar-month
      - "\U000F054A" # mdi-umbrella      
  
  # Includi Material Design Icons font
  # Grazie a https://community.home-assistant.io/t/display-materialdesign-icons-on-esphome-attached-to-screen/199790/16
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_large
    size: 90
    glyphs: &mdi-weather-glyphs
      - "\U000F054A" # mdi-umbrella
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0E6E" # mdi-weather-cloudy-arrow-right
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0F30" # mdi-weather-hazy
      - "\U000F0898" # mdi-weather-hurricane
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-night
      - "\U000F0F31" # mdi-weather-night-partly-cloudy
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0F32" # mdi-weather-partly-lightning
      - "\U000F0F33" # mdi-weather-partly-rainy
      - "\U000F0F34" # mdi-weather-partly-snowy
      - "\U000F0F35" # mdi-weather-partly-snowy-rainy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F0F36" # mdi-weather-snowy-heavy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F0F37" # mdi-weather-sunny-alert
      - "\U000F14E4" # mdi-weather-sunny-off
      - "\U000F059A" # mdi-weather-sunset
      - "\U000F059B" # mdi-weather-sunset-down
      - "\U000F059C" # mdi-weather-sunset-up
      - "\U000F0F38" # mdi-weather-tornado
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant
      - "\U000F06CC" # mdi delete-empty
      - "\U000F0A72" # mdi-solar-power
      - "\U000F051F" # mdi-timer-sand

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_medium
    size: 60
    glyphs: *mdi-weather-glyphs

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_extra_large
    size: 190
    glyphs: &mdi-loading-glyphs    
      - "\U000F051F" # timer-sand  

# Pins per la Waveshare ePaper ESP Board
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Ora visualizziamo tutto sullo schermo ePaper.
display:
  - platform: waveshare_epaper
    id: eink_display
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin:
      number: GPIO25
      inverted: true    
    reset_pin: GPIO26
    reset_duration: 2ms
    model: 7.50in-bV3
    update_interval: never
    rotation: 90Â°

    pages:
      - id: pagina1
        lambda: |-

          // Definizione colori in italiano
          const auto colore_nero = Color(255,255,255);
          const auto colore_bianco = Color(0,0,0);

          // Pulisce lo schermo prima di scrivere
          it.clear();

          // Riempie tutto lo schermo di bianco
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), colore_bianco);

          // Funzione lambda per tradurre il nome del giorno dall'inglese all'italiano
          auto translate_day = [](const std::string &day) -> std::string {
            if (day == "Monday")    return "LUN";
            if (day == "Tuesday")   return "MAR";
            if (day == "Wednesday") return "MER";
            if (day == "Thursday")  return "GIO";
            if (day == "Friday")    return "VEN";
            if (day == "Saturday")  return "SAB";
            if (day == "Sunday")    return "DOM";
            return day;
          };

          // Ottiene il giorno attuale in italiano
          char day_buffer[20];
          auto time_now = id(ntp).now();
          strftime(day_buffer, sizeof(day_buffer), "%A", localtime(&time_now.timestamp));
          std::string day_it = translate_day(day_buffer);

          // Definizione delle costanti per il layout e le posizioni
          #define xres 480 
          #define yres 800
          #define x_pad 10
          #define y_pad 20
          #define y_blocco_meteo 130
          #define y_blocco_previsioni 325
          #define y_blocco_calendario 490
          #define weather_icon_x xres/4-x_pad
          #define y_data 18

          // Mappa delle icone meteo: associa condizione a icona Unicode
          std::map<std::string, std::string> weather_icon_map {
            {"clear",                   "\U000F0599"}, 
            {"cloudy",                  "\U000F0590"}, 
            {"cloudy-alert",            "\U000F0F2F"},
            {"cloudy-arrow-right",      "\U000F0E6E"}, 
            {"fog",                     "\U000F0591"}, 
            {"hail",                    "\U000F0592"},
            {"hazy",                    "\U000F0F30"}, 
            {"hurricane",               "\U000F0898"}, 
            {"lightning",               "\U000F0593"},
            {"lightning-rainy",         "\U000F067E"}, 
            {"clear-night",             "\U000F0594"}, 
            {"night",                   "\U000F0594"},
            {"night-partly-cloudy",     "\U000F0F31"}, 
            {"partlycloudy",            "\U000F0595"},
            {"partly-lightning",        "\U000F0F32"}, 
            {"partly-rainy",            "\U000F0F33"},
            {"partlycloudy-light-rain", "\U000F0F33"}, 
            {"partly-snowy",            "\U000F0F34"},
            {"partly-snowy-rainy",      "\U000F0F35"}, 
            {"pouring",                 "\U000F0596"},
            {"rainy",                   "\U000F0597"}, 
            {"snowy",                   "\U000F0598"}, 
            {"snowy-heavy",             "\U000F0F36"},
            {"snowy-rainy",             "\U000F067F"}, 
            {"sunny",                   "\U000F0599"}, 
            {"sunny-alert",             "\U000F0F37"},
            {"sunny-off",               "\U000F14E4"}, 
            {"sunset",                  "\U000F059A"}, 
            {"sunset-down",             "\U000F059B"},
            {"sunset-up",               "\U000F059C"}, 
            {"tornado",                 "\U000F0F38"}, 
            {"windy",                   "\U000F059D"},
            {"windy-variant",           "\U000F059E"},
            {"umbrella",                "\U000F054A"},
          };

          // Se i dati meteo non sono disponibili, mostra un'icona di caricamento
          if (isnan(id(meteo_temperatura_ora).state)) {
            it.printf(240, 260, id(font_mdi_extra_large), TextAlign::TOP_CENTER, "\U000F051F");
            it.printf(240, 500, id(small_font), TextAlign::TOP_CENTER, "Caricamento dati....");
          } else {

            // ======= SEZIONE DATA =======
            const int data_center_x = x_pad + 230;
            const int data_top_y = y_data - 15;
            const int rect_width = 470;
            const int rect_height = 90;

            // Ottieni tempo attuale
            auto now_ntp = id(ntp).now();

            // Funzione lambda per tradurre il nome del mese in italiano
            auto translate_month = [](int month) -> std::string {
              const std::string mesi[] = {
                "GEN", "FEB", "MAR", "APR", "MAG", "GIU",
                "LUG", "AGO", "SET", "OTT", "NOV", "DIC"
              };
              if (month >= 1 && month <= 12)
                return mesi[month - 1];
              return "";
            };

            // Verifica il valore selezionato da Home Assistant
            if (id(scelta_data).state == "Data alfanumerica") {
              // Componi stringa della data: "MartedÃ¬ 13 Maggio"
              char data_completa[40];
              snprintf(data_completa, sizeof(data_completa), "%s %d %s", 
                      day_it.c_str(), now_ntp.day_of_month, translate_month(now_ntp.month).c_str());

              //it.printf(data_center_x, data_top_y + rect_height / 2, id(xtra_large_fontm2), colore_nero, TextAlign::CENTER, "%s", data_completa);
              if (id(scelta_data).state == "Data alfanumerica") {
                // Scomposizione della data
                std::string giorno_settimana = day_it;
                char giorno[3];
                snprintf(giorno, sizeof(giorno), "%d", now_ntp.day_of_month);
                std::string mese = translate_month(now_ntp.month);

                // Centri orizzontali: [95] [240] [385]
                const int x1 = 95;   // giorno della settimana
                const int x2 = 240;  // giorno numerico
                const int x3 = 385;  // mese

                // Coordinata verticale
                const int y_center = data_top_y + rect_height / 2;

                // Stampa
                it.printf(x1, y_center, id(xtra_large_fontm), colore_nero, TextAlign::CENTER, "%s", giorno_settimana.c_str());
                it.printf(x2, y_center, id(xtra_large_font),  colore_nero, TextAlign::CENTER, "%s", giorno);
                it.printf(x3, y_center, id(xtra_large_fontm), colore_nero, TextAlign::CENTER, "%s", mese.c_str());
              }

            } else {
              // Mostra la data in formato numerico: "13/05/25"
              it.printf(data_center_x, data_top_y + rect_height / 2, id(xtra_large_font), colore_nero, TextAlign::CENTER, "%02d/%02d/%02d", 
                        now_ntp.day_of_month, now_ntp.month, now_ntp.year % 100);
            }

            // ======= SEZIONE METEO =======
            // Titolo "METEO" e linea di separazione
            it.printf(xres / 2, y_blocco_meteo, id(medium_fontb), colore_nero, TextAlign::BASELINE_CENTER, "METEO");

            // Linea a sinistra del testo (fino a 10px prima del testo stimato largo 100px)
            it.line(x_pad, y_blocco_meteo - 10, xres / 2 - 100 / 2 - 30, y_blocco_meteo - 10);

            // Linea a destra del testo (da 10px dopo il testo fino a margine destro)
            it.line(xres / 2 + 100 / 2 + 30, y_blocco_meteo - 10, xres - x_pad, y_blocco_meteo - 10);

            // === Segnale Wi-Fi dinamico ===
            int wifi_rssi = id(segnale_wifi).state;  // normalmente Ã¨ in dBm (es: -70)
            const char* wifi_icon;

            if (isnan(wifi_rssi) || wifi_rssi < -90)       wifi_icon = "\U000F05AA"; // wifi-off
            else if (wifi_rssi < -80)                      wifi_icon = "\U000F091F"; // strength-1
            else if (wifi_rssi < -70)                      wifi_icon = "\U000F0922"; // strength-2
            else if (wifi_rssi < -60)                      wifi_icon = "\U000F0925"; // strength-3
            else                                           wifi_icon = "\U000F0928"; // strength-4

            it.printf(x_pad + 5, y_blocco_meteo - 15, id(font_icons_small), colore_nero, TextAlign::BASELINE_LEFT, "%s", wifi_icon);
            it.printf(x_pad + 100, y_blocco_meteo - 15, id(xtra_small_font), colore_nero, TextAlign::BASELINE_RIGHT, "%d dBm", wifi_rssi);

            // === Batteria dinamica ===
            float batt = id(Batteria_Livello).state;  // Livello batteria in percentuale
            const char* batt_icon;

            // Scegli icona in base al livello
            if (batt < 10)       batt_icon = "\U000F007A"; // battery-10
            else if (batt < 20)  batt_icon = "\U000F007B"; // battery-20
            else if (batt < 30)  batt_icon = "\U000F007C"; // battery-30
            else if (batt < 40)  batt_icon = "\U000F007D"; // battery-40
            else if (batt < 50)  batt_icon = "\U000F007E"; // battery-50
            else if (batt < 60)  batt_icon = "\U000F007F"; // battery-60
            else if (batt < 70)  batt_icon = "\U000F0080"; // battery-70
            else if (batt < 80)  batt_icon = "\U000F0081"; // battery-80
            else if (batt < 90)  batt_icon = "\U000F0082"; // battery-90
            else                 batt_icon = "\U000F0079"; // battery-full

            it.printf(xres - x_pad - 48, y_blocco_meteo - 15, id(font_icons_small), colore_nero, TextAlign::BASELINE_RIGHT, batt_icon);
            it.printf(xres - x_pad, y_blocco_meteo - 15, id(xtra_small_font), colore_nero, TextAlign::BASELINE_RIGHT, "%2.0f%%", batt);

            // - Temperatura Esterna -
            it.printf(xres / 2, y_blocco_meteo+115,    id(xtra_large_fontm),  colore_nero, TextAlign::BASELINE_CENTER, "%2.1fÂ°", id(meteo_temperatura_ora).state);

            // - UmiditÃ  Esterna -
            it.printf(x_pad, y_blocco_meteo+55,         id(font_icons_medium), colore_nero, TextAlign::BASELINE_LEFT, "\U000F058E");
            it.printf(x_pad+35, y_blocco_meteo+51,      id(xtra_small_font),      colore_nero, TextAlign::BASELINE_LEFT, "%2.0f%%", id(meteo_umidita_ora).state);

            // - Pressione Esterna -
            it.printf(x_pad, y_blocco_meteo+95,         id(font_icons_medium), colore_nero, TextAlign::BASELINE_LEFT, "\U000F029A");
            it.printf(x_pad+35, y_blocco_meteo+91,      id(xtra_small_font),      colore_nero, TextAlign::BASELINE_LEFT, "%4.0f hPa", id(meteo_pressione_ora).state); 

            // - Pioggia -
            it.printf(x_pad, y_blocco_meteo+135,        id(font_icons_medium), colore_nero, TextAlign::BASELINE_LEFT, "\U000F054A");
            it.printf(x_pad+35, y_blocco_meteo+131,     id(xtra_small_font),      colore_nero, TextAlign::BASELINE_LEFT, "%2.0f mm", id(meteo_precipitazione_ora).state);

            // -Icona Meteo -
            it.printf(xres-x_pad-20, y_blocco_meteo+120,   id(font_mdi_large),    colore_nero, TextAlign::BASELINE_RIGHT, "%s", weather_icon_map[id(meteo_condizione_ora).state.c_str()].c_str());

            // ======= SEZIONE PREVISIONI =======
            // Scritta "PREVISIONI" centrata
            it.printf(xres / 2, y_blocco_previsioni, id(medium_fontb), colore_nero, TextAlign::BASELINE_CENTER, "PREVISIONI");

            // Linea a sinistra (testo â‰ˆ 10 caratteri, stimiamo 200px larghezza)
            it.line(x_pad, y_blocco_previsioni - 10, xres / 2 - 200 / 2 - 30, y_blocco_previsioni - 10);

            // Linea a destra
            it.line(xres / 2 + 200 / 2 + 30, y_blocco_previsioni - 10, xres - x_pad, y_blocco_previsioni - 10);

            // ======= SEZIONE PREVISIONI DINAMICHE =======
            if (tipo_previsioni_ha->state == "Giornaliere") {
              // Mostra le previsioni giornaliere
              int num_giorni = static_cast<int>(id(giorni_previsioni_ha).state);
              const int base_y = y_blocco_previsioni;
              const int spacing_x = (xres - 2 * x_pad) / num_giorni;

              for (int i = 0; i < num_giorni; i++) {
                int x = x_pad + i * spacing_x;
                std::string giorno;

                // Giorno della settimana per le previsioni giornaliere
                if (i == 0) giorno = translate_day(id(meteo_giorno_1d).state);
                else if (i == 1) giorno = translate_day(id(meteo_giorno_2d).state);
                else if (i == 2) giorno = translate_day(id(meteo_giorno_3d).state);
                else giorno = translate_day(id(meteo_giorno_4d).state);
          
                it.printf(x + spacing_x / 2, base_y + 15, id(xtra_small_font), colore_nero, TextAlign::TOP_CENTER, "%s", giorno.c_str());

                // Icona meteo
                std::string condizione;
                if (i == 0) condizione = id(meteo_condizione_1d).state;
                else if (i == 1) condizione = id(meteo_condizione_2d).state;
                else if (i == 2) condizione = id(meteo_condizione_3d).state;
                else condizione = id(meteo_condizione_4d).state;

                std::string icona = weather_icon_map[condizione];
                it.printf(x + spacing_x / 2, base_y + 40, id(font_mdi_medium), colore_nero, TextAlign::TOP_CENTER, "%s", icona.c_str());

                // Temperatura
                float temperatura;
                if (i == 0) temperatura = id(meteo_temperatura_1d).state;
                else if (i == 1) temperatura = id(meteo_temperatura_2d).state;
                else if (i == 2) temperatura = id(meteo_temperatura_3d).state;
                else temperatura = id(meteo_temperatura_4d).state;

                char temp_str[6];
                snprintf(temp_str, sizeof(temp_str), "%.0f", temperatura);
                it.printf(x + spacing_x / 2, base_y + 105, id(xtra_small_font), colore_nero, TextAlign::TOP_CENTER, "%sÂ°", temp_str);
              }
            } else if (tipo_previsioni_ha->state == "Orarie") {
              // Mostra le previsioni orarie
              int num_ore = static_cast<int>(id(ore_previsioni_ha).state);  // Ad esempio, 4 ore max supportato
              const int base_y = y_blocco_previsioni;
              const int spacing_x = (xres - 2 * x_pad) / num_ore;

              for (int i = 0; i < num_ore; i++) {
                int x = x_pad + i * spacing_x;
                std::string ora;
                if (i == 0) ora = id(meteo_orario_1o).state;
                else if (i == 1) ora = id(meteo_orario_2o).state;
                else if (i == 2) ora = id(meteo_orario_3o).state;
                else ora = id(meteo_orario_4o).state;

                it.printf(x + spacing_x / 2, base_y + 15, id(xtra_small_font), colore_nero, TextAlign::TOP_CENTER, "%s", ora.c_str());

                // Icona meteo per ogni ora
                std::string condizione;
                if (i == 0) condizione = id(meteo_condizione_1o).state;
                else if (i == 1) condizione = id(meteo_condizione_2o).state;
                else if (i == 2) condizione = id(meteo_condizione_3o).state;
                else condizione = id(meteo_condizione_4o).state;

                std::string icona = weather_icon_map[condizione];
                it.printf(x + spacing_x / 2, base_y + 40, id(font_mdi_medium), colore_nero, TextAlign::TOP_CENTER, "%s", icona.c_str());

                // Temperatura oraria
                float temperatura;
                if (i == 0) temperatura = id(meteo_temperatura_1o).state;
                else if (i == 1) temperatura = id(meteo_temperatura_2o).state;
                else if (i == 2) temperatura = id(meteo_temperatura_3o).state;
                else temperatura = id(meteo_temperatura_4o).state;

                char temp_str[6];
                snprintf(temp_str, sizeof(temp_str), "%.0f", temperatura);
                it.printf(x + spacing_x / 2, base_y + 105, id(xtra_small_font), colore_nero, TextAlign::TOP_CENTER, "%sÂ°", temp_str);
              }
            }

            // ======= SEZIONE CALENDARIO =======
            // Scritta "CALENDARIO" centrata
            it.printf(xres / 2, y_blocco_calendario + 4, id(medium_fontb), colore_nero, TextAlign::BASELINE_CENTER, "CALENDARIO");

            // Linea a sinistra (testo â‰ˆ 220px largo)
            it.line(x_pad, y_blocco_calendario - 6, xres / 2 - 220 / 2 - 30, y_blocco_calendario - 6);

            // Linea a destra
            it.line(xres / 2 + 220 / 2 + 30, y_blocco_calendario - 6, xres - x_pad, y_blocco_calendario - 6);

            // - Dimensioni ottimizzate per il layout -
            int y = y_blocco_calendario+10;   // Posizione iniziale verticale
            int block_spacing = 2;      // Spaziatura ridotta tra i blocchi
            int block_height = 60;      // Altezza totale di un blocco giorno
            int day_font_height = 26;   // Altezza del font per il giorno
            int event_font_height = 18; // Altezza del font per gli eventi
            int event_spacing = 4;      // Spaziatura tra eventi

            // Mostra eventi per i prossimi 4 giorni con normalizzazione della data
            struct Giorno {
              const char* nome;
              text_sensor::TextSensor* eventi;
            };

            std::vector<Giorno> giorni = {
              {"LUNEDÃŒ",    id(eventi_lunedi)},
              {"MARTEDÃŒ",   id(eventi_martedi)},
              {"MERCOLEDÃŒ", id(eventi_mercoledi)},
              {"GIOVEDÃŒ",   id(eventi_giovedi)},
              {"VENERDÃŒ",   id(eventi_venerdi)},
              {"SABATO",    id(eventi_sabato)},
              {"DOMENICA",  id(eventi_domenica)},
            };

            // Calcola il giorno corrente
            int today = id(homeassistant_time).now().day_of_week;
            int giorni_offset = today - 2;
            if (giorni_offset < 0) giorni_offset += 7;

            auto now = id(homeassistant_time).now();

            for (int i = 0; i < 4; i++) {
              int idx = (giorni_offset + i) % 7;
              auto &g = giorni[idx];

              ESPTime day_date = now;
              day_date.day_of_month += i;

              // Normalizza la data
              while (true) {
                int days_in_month = 31;
                if (day_date.month == 4 || day_date.month == 6 || day_date.month == 9 || day_date.month == 11) days_in_month = 30;
                else if (day_date.month == 2) {
                  bool leap = (day_date.year % 4 == 0 && day_date.year % 100 != 0) || (day_date.year % 400 == 0);
                  days_in_month = leap ? 29 : 28;
                }
                if (day_date.day_of_month <= days_in_month) break;
                day_date.day_of_month -= days_in_month;
                day_date.month += 1;
                if (day_date.month > 12) {
                  day_date.month = 1;
                  day_date.year += 1;
                }
              }

              it.printf(10, y, id(small_font), colore_nero, TextAlign::TOP_LEFT, "%s %02d-%02d", g.nome, day_date.day_of_month, day_date.month);
              it.line(10, y + day_font_height + 2, xres - x_pad, y + day_font_height + 2, colore_nero);

              int event_y = y + day_font_height + event_spacing;
              if (g.eventi->has_state() && g.eventi->state.length() > 0) {
                it.printf(10, event_y, id(xtra_small_font), colore_nero, TextAlign::TOP_LEFT, g.eventi->state.c_str());
              }

              y += block_height + block_spacing;
            }

            // ====== SEZIONE AGGIORNAMENTO ======
            it.line(x_pad, yres-y_pad-18, xres-x_pad, yres-y_pad-18);           

            it.printf((xres/2), yres-y_pad+6, id(xtra_small_font), TextAlign::BASELINE_CENTER, 
              "Ultimo aggiornamento: %s %02d/%02d/%04d  %02d:%02d", day_it.c_str(), time_now.day_of_month, time_now.month, time_now.year, time_now.hour, time_now.minute);
          }

      - id: pagina2    # nero pieno per reset notturno
        lambda: |-
          //const auto colore_bianco = COLOR_OFF;
          //const auto colore_nero = COLOR_ON;
          const auto colore_nero = Color(255,255,255);
          const auto colore_bianco = Color(0,0,0);

          // Cancella lo schermo        
          it.clear();

          // Riempie tutto lo schermo di nero
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), colore_bianco);
